---
export const prerender = false;

import {
  and,
  ClassBooking,
  CreditLedger,
  db,
  eq,
  gte,
  lt,
  sum,
  TeacherScheduleRule,
} from "astro:db";
import { DashboardBookClassWidget } from "@/components/dashboard-book-class-widget";
import {
  buildMonthClassAvailability,
  getUtcRangeForKstMonth,
  type MonthClassAvailability,
} from "@/lib/booking-schedule";
import DashboardLayout from "@/layouts/dashboard/layout.astro";

const CLASS_DURATION_MINUTES = 50;

const user = Astro.locals.user;

if (!user) {
  return Astro.redirect("/auth/login");
}

const creditBalanceRow = await db
  .select({ credits: sum(CreditLedger.creditsDelta) })
  .from(CreditLedger)
  .where(eq(CreditLedger.userId, user.id))
  .get();

const creditBalance = Number(creditBalanceRow?.credits ?? 0);

const monthFormatter = new Intl.DateTimeFormat("en-CA", {
  timeZone: "Asia/Seoul",
  year: "numeric",
  month: "2-digit",
});

const monthParts = monthFormatter.formatToParts(new Date());
const currentYear = monthParts.find((part) => part.type === "year")?.value;
const currentMonth = monthParts.find((part) => part.type === "month")?.value;

if (!currentYear || !currentMonth) {
  throw new Error("Failed to resolve current KST month");
}

const currentMonthKey = `${currentYear}-${currentMonth}`;

function addMonthsToMonthKey(monthKey: string, delta: number) {
  const [yearPart, monthPart] = monthKey.split("-");
  const year = Number(yearPart);
  const month = Number(monthPart);

  if (Number.isNaN(year) || Number.isNaN(month)) {
    throw new Error("Invalid month key");
  }

  const date = new Date(Date.UTC(year, month - 1 + delta, 1, 12, 0, 0));

  return `${date.getUTCFullYear()}-${String(date.getUTCMonth() + 1).padStart(2, "0")}`;
}

const PRELOADED_MONTHS_COUNT = 3;
const preloadedMonthKeys = Array.from(
  { length: PRELOADED_MONTHS_COUNT },
  (_, index) => addMonthsToMonthKey(currentMonthKey, index),
);

const scheduleRules = await db
  .select()
  .from(TeacherScheduleRule)
  .where(eq(TeacherScheduleRule.isActive, true));

const initialMonthAvailabilityMap: Record<string, MonthClassAvailability> = {};

if (scheduleRules.length > 0) {
  const firstMonthRange = getUtcRangeForKstMonth(preloadedMonthKeys[0]);
  const lastMonthRange = getUtcRangeForKstMonth(
    addMonthsToMonthKey(preloadedMonthKeys[preloadedMonthKeys.length - 1], 1),
  );

  const bookedClasses = await db
    .select({ startsAt: ClassBooking.startsAt })
    .from(ClassBooking)
    .where(
      and(
        eq(ClassBooking.status, "booked"),
        gte(ClassBooking.startsAt, firstMonthRange.startAt),
        lt(ClassBooking.startsAt, lastMonthRange.startAt),
      ),
    );

  const bookedStartsAt = new Set(
    bookedClasses.map((booking) => new Date(booking.startsAt).getTime()),
  );

  for (const monthKey of preloadedMonthKeys) {
    initialMonthAvailabilityMap[monthKey] = buildMonthClassAvailability({
      kstMonth: monthKey,
      rules: scheduleRules,
      bookedStartsAt,
    });
  }
}
---

<DashboardLayout title="Book a Class">
  <div class="space-y-6">
    <section class="space-y-2">
      <h1 class="text-2xl font-semibold">Book a Class</h1>
      <p class="text-sm text-muted-foreground">
        Select a date and book an available class slot in KST.
      </p>
      <p class="text-sm text-muted-foreground">
        1 credit = 1 class ({CLASS_DURATION_MINUTES} minutes)
      </p>
      <p class="text-sm font-medium">
        Current balance: {creditBalance} credits
      </p>
    </section>

    <DashboardBookClassWidget
      client:load
      creditBalance={creditBalance}
      initialMonthKey={currentMonthKey}
      initialMonthAvailabilityMap={initialMonthAvailabilityMap}
    />
  </div>
</DashboardLayout>
